# 업무 자동화 시 빠지기 쉬운 안티패턴

> 안티패턴이란? 겉보기엔 그럴싸해 보이지만, 결국 더 큰 문제를 만들어내는 나쁜 습관.
> 자동화는 잘못 만들면 "일을 줄이는 도구"가 아니라 "더 큰 일을 만드는 시한폭탄"이 됩니다.

---

## 안티패턴 1: 깨지기 쉬운 자동화 (Fragile Scripting)

### 증상
- 평소엔 잘 돌아가다가, 딱 한 번 예외 상황이 생기면 전체가 멈춘다.
- 에러 메시지가 어디서 났는지 알 수 없다.
- 자동화가 멈춘 것 자체를 한참 후에야 알아챈다.

### 문제
마치 도미노처럼, 첫 번째 칸이 넘어지면 뒤에 줄 세워놓은 모든 것이 함께 쓰러집니다. 예외를 전혀 고려하지 않고 만든 자동화는 "이상적인 상황에서만 작동하는" 구조입니다.

### 위험한 예시
- 엑셀 파일명이 항상 동일하다고 가정하고 만든 자동화 → 누가 파일명을 바꾸면 즉시 오류
- 인터넷 연결이 항상 된다고 가정 → 인터넷이 끊기면 전체 중단
- API가 항상 응답한다고 가정 → 외부 서비스 장애 시 전체 멈춤

### 해결
AI에게 자동화를 요청할 때 반드시 이렇게 말하세요:
> "에러가 생겼을 때 자동화가 완전히 멈추지 않도록, 각 단계에서 실패하면 어떻게 처리할지 함께 설계해줘. 에러 내용은 로그로 남겨줘."

---

## 안티패턴 2: 수동 개입 의존 (Manual Dependency)

### 증상
- "자동화"라고 만들었는데, 중간에 사람이 버튼을 눌러야 다음 단계로 넘어간다.
- 담당자가 자리를 비우면 자동화도 멈춘다.
- 자동화를 위한 자동화를 관리하는 데 시간이 더 든다.

### 문제
비유하면, 자동 세탁기를 사놓고 "세탁→헹굼 전환"을 사람이 버튼으로 눌러야 하는 구조입니다. 세탁기를 산 의미가 없습니다.

### 위험한 예시
- 데이터를 수집한 후 "확인 후 다음 단계 진행" 대기가 필요한 구조
- 보고서 자동 생성 후 사람이 직접 이메일 첨부해서 발송
- 자동화 스크립트가 특정 사람의 PC에서만 실행 가능

### 해결
> "이 워크플로우에서 사람이 직접 해야 하는 단계가 있으면 알려줘. 그 단계도 자동화할 수 있는 방법을 제안해줘."

---

## 안티패턴 3: 보안 방치 (Security Leak)

### 증상
- API 키, 비밀번호, 접속 토큰이 코드 파일 안에 그대로 적혀 있다.
- 자동화 코드를 다른 사람과 공유할 때 민감 정보가 함께 노출된다.
- GitHub 같은 곳에 코드를 올렸다가 계정이 해킹당한다.

### 문제
마치 집 열쇠를 현관문 위에 붙여놓는 것과 같습니다. 코드가 공유되는 순간 모든 접근 권한이 함께 공유됩니다.

### 위험한 예시
```
# 절대 하면 안 되는 것
api_key = "sk-1234abcd..."
password = "mypassword123"
```

### 해결
> "API 키나 비밀번호는 코드에 직접 넣지 말고, 환경 변수나 별도 설정 파일로 분리해서 관리하는 방식으로 만들어줘."

환경 변수는 집 열쇠를 코드 밖 금고에 넣어두고, 코드는 "금고 번호"만 아는 구조입니다.

---

## 안티패턴 4: 일회성 자동화 (One-Time Scripting)

### 증상
- 이번에는 잘 됐는데, 다음 달에 같은 작업을 하려니 처음부터 다시 만들어야 한다.
- 회사명, 날짜, 파일 경로가 코드 안에 하드코딩되어 있다.
- 다른 팀이 비슷한 자동화가 필요한데 재사용이 불가능하다.

### 문제
비유하면, 매번 새 레시피를 쓰는 게 아니라, 재료 이름만 바꿔 쓸 수 있는 레시피 템플릿을 만들어야 합니다. 일회성 자동화는 자동화가 아니라 "한 번 실행되는 스크립트"일 뿐입니다.

### 해결
> "이 자동화를 나중에도 재사용할 수 있도록, 변경될 수 있는 값들(날짜, 파일명, 대상 이름 등)은 설정으로 분리해서 만들어줘."

---

## 안티패턴 5: 과잉 자동화 (Over-Automation)

### 증상
- 자동화 구축에 3시간을 썼는데, 수동으로 하면 5분이면 되는 작업이다.
- 자동화 유지보수에 시간이 더 든다.
- "자동화했다"는 성취감이 생산성을 착각하게 만든다.

### 문제
자동화는 만능이 아닙니다. 1년에 한 번 하는 작업을 자동화하는 것은 투자 대비 효과(ROI)가 없습니다.

### ROI 계산법
> 자동화할 가치가 있는가?
> = (절약되는 시간 × 반복 횟수) > (자동화 구축 시간 + 유지보수 시간)

### 해결
자동화 요청 전에 먼저 물어보세요:
- 이 작업을 얼마나 자주 하는가?
- 수동으로 하면 얼마나 걸리는가?
- 자동화 구축에 얼마나 걸릴 것 같은가?

---

## 안티패턴 6: 모니터링 부재 (Silent Failure)

### 증상
- 자동화를 실행해두고 결과를 확인하지 않는다.
- 며칠 후에야 자동화가 멈춰있었다는 것을 알게 된다.
- 오류가 났는데 어디서 났는지 알 수 없다.

### 문제
자동화는 "세팅하고 잊어버리는" 것이 아닙니다. 자동차도 계기판이 있어야 이상을 감지할 수 있듯, 자동화도 상태를 알 수 있는 장치가 필요합니다.

### 해결
> "이 자동화가 실패하면 나한테 이메일(또는 슬랙 메시지)로 알림을 보내줘. 성공했을 때도 간단한 완료 로그를 남겨줘."

---

## 안티패턴 7: 문서화 부재 (Black Box Automation)

### 증상
- 6개월 전에 만든 자동화가 뭘 하는지 본인도 모른다.
- 담당자가 바뀌면 아무도 이해할 수 없는 블랙박스가 된다.
- 수정하려다가 더 망가뜨린다.

### 문제
자동화는 "실행되는 문서"여야 합니다. 코드는 기계가 읽는 것이고, 주석과 설명은 사람이 읽는 것입니다. 둘 다 있어야 합니다.

### 해결
> "이 자동화에 주석을 달아줘. 각 단계가 무엇을 하는지, 왜 이렇게 설계했는지 한국어로 설명해줘. 별도로 README 파일도 만들어줘."

---

## 안티패턴 8: 단일 장애점 (Single Point of Failure)

### 증상
- A 단계가 실패하면 B, C, D 단계 모두 실행이 안 된다.
- 하나의 도구/서비스에만 의존하고 있어, 그 서비스가 내려가면 전체가 멈춘다.
- 자동화 전체가 하나의 거대한 덩어리로 되어 있다.

### 문제
비유하면, 도미노 첫 번째 칸이 쓰러지면 전부 쓰러지는 구조입니다. 각 단계가 독립적으로 실행될 수 있어야 합니다.

### 해결
> "각 단계를 독립적인 모듈로 나눠서, 한 단계가 실패해도 다른 단계는 계속 실행될 수 있도록 설계해줘."

---

## 위험 신호 체크리스트

자동화를 만들기 전, 아래 항목을 점검하세요. 하나라도 해당되면 설계를 다시 검토하세요.

### 설계 단계 체크
- [ ] 에러가 났을 때 어떻게 처리할지 생각해봤는가?
- [ ] 자동화 중간에 사람이 개입해야 하는 단계가 있는가?
- [ ] API 키나 비밀번호를 코드 안에 직접 넣으려 하는가?
- [ ] 이 자동화를 나중에도 재사용할 수 있는가?
- [ ] 자동화할 만큼 충분히 반복되는 작업인가?

### 완성 후 체크
- [ ] 실패 시 알림이 오는가?
- [ ] 실행 로그가 남는가?
- [ ] 6개월 후 다른 사람이 이 코드를 이해할 수 있는가?
- [ ] 특정 서비스가 내려가도 부분적으로 작동하는가?
- [ ] 설정값(날짜, 파일명 등)이 코드와 분리되어 있는가?

---

## AI에게 자동화 요청할 때 쓰는 문장 템플릿

```
다음 작업을 자동화해줘:
[작업 내용]

요구사항:
- 에러가 발생하면 로그로 기록하고, 나에게 알림을 줘
- API 키나 비밀번호는 환경 변수로 분리해줘
- 나중에 재사용할 수 있도록 변경 가능한 값은 설정으로 분리해줘
- 각 단계에 한국어 주석을 달아줘
- 실행 완료 후 결과 요약을 보여줘
```

이 템플릿 하나만 기억해도 8가지 안티패턴 중 6가지를 예방할 수 있습니다.
